import logging
from dataclasses import dataclass
from pathlib import Path
from typing import Callable, Sequence

import matplotlib.pyplot as plt
import numpy as np
import scipy.sparse.linalg as spla
from matplotlib.image import AxesImage
from scipy import fft, ndimage, sparse

from lrs_psido.linear_operators import RealPDOLowRankSymbol
from utils.bilaplacian_prior import (
    BiLaplacianComputeCoefficients,
    BilaplacianPrior,
    BilaplacianPriorWithoutBC,
)
from utils.make_window import make_window, tukey_window_2d
from utils.wave_modeling_julia import WaveModeling

logger = logging.getLogger(__name__)


@dataclass
class SeismicInverseProblem:

    # Geometry
    Lx: float
    Ly: float
    nx: int
    ny: int

    # Model
    cmin: float
    cmax: float
    smooth_sigma: float = None  # Smooth factor for initial guess
    mt: np.ndarray = None  # True model
    m0: np.ndarray = None  # Initial model. If none, will be generated by smoothing mt

    # Frequency
    fmin: float = np.nan
    fmax: float = np.nan

    # Experiment settings
    n_src: int = np.nan
    n_rcv: int = np.nan
    T: float = np.nan
    nt: int = np.nan

    # Dictionary config
    window_config: dict = None
    prior_config: dict = None
    plot_config: dict = None

    # Misfit
    compute_f: Callable[[np.ndarray], float] = None  # Compute L2-misfit f(m)
    compute_g: Callable[[np.ndarray], np.ndarray] = None  # Compute gradient g(m)
    compute_Hv: Callable[[np.ndarray, np.ndarray], np.ndarray] = (
        None  # Compute Hessian-vector product Hv(m,v) = H(m) v
    )
    noise_variance: float = None

    label: str = None  # Experiment label
    path: Path = None  # Experiment path

    def __post_init__(self):
        self.path = Path(self.path)
        self.get_geometry()
        self.get_model()
        self.get_window()
        self.get_prior()
        self.get_plotters()

    def get_geometry(self):
        logger.debug("Get geometry...")
        self.dx = self.Lx / (self.nx - 1)
        self.dy = self.Ly / (self.ny - 1)
        self.L = np.array([self.Lx, self.Ly]).astype(float)
        self.n = np.array([self.nx, self.ny]).astype(int)
        self.d = np.array([self.dx, self.dy]).astype(float)
        self.N = np.prod(self.n)
        self.kmax = np.pi / self.d  # max wavenumber
        self.dt: float = self.T / (self.nt - 1)

        # Grids (may be used at some time)
        xx = np.linspace(0, self.Lx, self.nx)
        yy = np.linspace(0, self.Ly, self.ny)
        xxf = fft.fftfreq(self.nx, self.dx) * 2 * np.pi * self.nx / (self.nx - 1)
        yyf = fft.fftfreq(self.ny, self.dy) * 2 * np.pi * self.ny / (self.ny - 1)
        self.XX, self.YY = np.meshgrid(xx, yy, indexing="ij")
        self.XXf, self.YYf = np.meshgrid(xxf, yyf, indexing="ij")
        self.RRf = np.sqrt(self.XXf**2 + self.YYf**2)
        self.AAf = np.arctan2(self.YYf, self.XXf)

    def get_model(self):
        logger.debug("Get models...")
        self.mt: np.ndarray = self.mt.astype(float).reshape(-1)
        logger.debug(f"Clip mt to fit into interval [{self.cmin}, {self.cmax}].")
        np.clip(self.mt, self.cmin, self.cmax, out=self.mt)

        # Initial Model
        if self.m0 is not None:
            logger.debug(f"m0 is given. Clip m0 into [{self.cmin}, {self.cmax}].")
            self.m0: np.ndarray = self.m0.astype(float).reshape(-1)
            np.clip(self.m0, self.cmin, self.cmax, out=self.m0)
        else:
            logger.debug(f"m0 is not given. Try to generate m0.")
            if self.smooth_sigma is not None:
                logger.debug(f"smooth_sigma is given. m0 = smoothen(mt).")
                self.m0: np.ndarray = ndimage.gaussian_filter(
                    self.mt.reshape(self.n), sigma=self.smooth_sigma, mode="nearest"
                ).reshape(-1)
            else:
                logger.debug(f"smooth_sigma is not given. m0 = 0.")
                self.m0: np.ndarray = np.zeros_like(self.mt)

    def get_window(self):
        logger.debug("Generating windowing matrix...")
        kwargs = self.window_config.copy()
        method = kwargs.pop("method", "exp")
        window = make_window(method, self.n, **kwargs)
        self.window = window
        self.W = spla.aslinearoperator(sparse.diags(window.ravel()))

    def get_prior(self):
        logger.debug("Building prior...")
        name = self.prior_config.get("name")
        if name == "bilaplacian":
            default_rho = self.m0.min() / self.fmax * 0.5
            rho = self.prior_config.get("rho", default_rho)  # correlation length
            sigma2 = self.prior_config.get("sigma2")  # marginal variance
            gamma, delta = BiLaplacianComputeCoefficients(sigma2, rho, ndim=2)
            logger.info(f"Bilaplacian prior: {delta = :.4e}, {gamma = :.4e}")
            self.prior = BilaplacianPrior(
                *self.n,
                *self.d,
                gamma * np.sqrt(self.d.prod()),
                delta * np.sqrt(self.d.prod()),
                mean=np.zeros(self.N),
            )
        elif name == "bilaplacian-without-bc":
            default_rho = self.m0.min() / self.fmax * 0.5
            rho = self.prior_config.get("rho", default_rho)  # correlation length
            sigma2 = self.prior_config.get("sigma2")  # marginal variance
            gamma, delta = BiLaplacianComputeCoefficients(sigma2, rho, ndim=2)
            logger.info(f"Bilaplacian prior: {delta = :.4e}, {gamma = :.4e}")
            self.prior = BilaplacianPriorWithoutBC(
                *self.n,
                *self.d,
                gamma * np.sqrt(self.d.prod()),
                delta * np.sqrt(self.d.prod()),
                mean=np.zeros(self.N),
            )
        else:
            raise ValueError(f"Unknown prior name {name}")

        self.R = spla.aslinearoperator(self.prior.R)
        self.sqrtR = spla.aslinearoperator(self.prior.Rh)
        solver_tol = np.finfo(np.float64).eps
        sqrtRsolve = lambda x: spla.cg(self.prior.Rh, x, rtol=solver_tol)[0]
        self.sqrtRinv = spla.LinearOperator(
            dtype=np.float64,
            shape=self.sqrtR.shape,
            matvec=sqrtRsolve,
            rmatvec=sqrtRsolve,
        )
        self.Rinv = self.sqrtRinv @ self.sqrtRinv.H

    # Misfit in terms of x = m - m0
    def orig_misfit_cost(self, x: np.ndarray) -> float:
        return self.compute_f(self.m0 + x) / self.noise_variance

    def orig_misfit_grad(self, x: np.ndarray) -> np.ndarray:
        return self.compute_g(self.m0 + x) / self.noise_variance

    def orig_misfit_hess(self, x: np.ndarray) -> spla.LinearOperator:
        return spla.LinearOperator(
            shape=(self.N, self.N),
            dtype=float,
            matvec=lambda v: self.compute_Hv(self.m0 + x, v) / self.noise_variance,
            rmatvec=lambda v: self.compute_Hv(self.m0 + x, v) / self.noise_variance,
        )

    # Misfit with windowing applied
    def misfit_cost(self, x: np.ndarray) -> float:
        return self.orig_misfit_cost(self.W * x)

    def misfit_grad(self, x: np.ndarray) -> np.ndarray:
        return self.W * self.orig_misfit_grad(self.W * x)

    def misfit_hess(self, x: np.ndarray) -> spla.LinearOperator:
        return self.W * self.orig_misfit_hess(self.W * x) * self.W

    # Total = Misfit + Regularization(neg-log-prior)
    def total_cost(self, x: np.ndarray) -> float:
        """cost(x) = misfit(m0+W*x) + reg(x)"""
        misfit = self.misfit_cost(x)
        reg = self.prior.cost(x)
        total = misfit + reg
        return total

    def total_grad(self, x: np.ndarray) -> np.ndarray:
        return self.misfit_grad(x) + self.prior.grad(x)

    def total_hess(self, x: np.ndarray) -> spla.LinearOperator:
        return self.misfit_hess(x) + self.R

    def get_plotters(self) -> None:
        plt.rcParams.update(self.plot_config["rcParams"])
        self.x_size = np.asarray(self.plot_config["x_size"])
        self.f_size = np.asarray(self.plot_config["f_size"])
        self.x_ratio = self.x_size[0] / self.x_size[1]
        self.f_ratio = self.f_size[0] / self.f_size[1]

    def plot(
        self,
        x: np.ndarray,
        title: str = None,
        colorbar: bool = False,
        cbar_label: str = None,
        **kwargs,
    ) -> AxesImage:
        kwargs.setdefault("extent", [0, self.Lx, self.Ly, 0])
        kwargs.setdefault("aspect", 1)
        im = plt.imshow(x.reshape(self.n).T, **kwargs)
        plt.xlabel("Offset (m)")
        plt.ylabel("Depth (m)")
        if title is not None:
            plt.title(title)
        if colorbar:
            cbar = plt.colorbar()
            if cbar_label is not None:
                cbar.set_label(cbar_label)
        return im

    def plotf(
        self,
        x: np.ndarray,
        title: str = None,
        colorbar: bool = False,
        cbar_label: str = None,
        **kwargs,
    ) -> AxesImage:
        kwargs.setdefault(
            "extent", [-self.kmax[0], self.kmax[0], self.kmax[1], -self.kmax[1]]
        )
        kwargs.setdefault("aspect", 1)
        im = plt.imshow(fft.fftshift(x.reshape(self.n).T), **kwargs)
        plt.xlabel("Wavenumber (1/m)")
        plt.ylabel("Wavenumber (1/m)")
        if title is not None:
            plt.title(title)
        if colorbar:
            cbar = plt.colorbar()
            if cbar_label is not None:
                cbar.set_label(cbar_label)
        return im

    def show(self) -> None:
        out_path = self.path / "model"
        out_path.mkdir(parents=True, exist_ok=True)

        # Save models
        np.save(out_path / "mt.npy", self.mt.reshape(self.n))
        np.save(out_path / "m0.npy", self.m0.reshape(self.n))

        # plot window
        plt.figure(figsize=self.x_size)
        self.plot(self.window, title="Window", colorbar=True)
        plt.tight_layout()
        plt.savefig(out_path / "window.png")

        # plot mture
        plt.figure(figsize=self.x_size)
        self.plot(
            self.mt, title="True Model", colorbar=True, cbar_label="Velocity (m/s)"
        )
        plt.tight_layout()
        plt.savefig(out_path / "mt.png")

        # plot m0
        plt.figure(figsize=self.x_size)
        self.plot(
            self.m0, title="Initial Model", colorbar=True, cbar_label="Velocity (m/s)"
        )
        plt.tight_layout()
        plt.savefig(out_path / "m0.png")

        # plot dmt
        dmt = self.mt - self.m0
        plt.figure(figsize=self.x_size)
        self.plot(
            dmt,
            title=r"Target Solution $x^* = m_{true}-m_0$",
            colorbar=True,
            cbar_label="Velocity (m/s)",
        )
        plt.tight_layout()
        plt.savefig(out_path / "dmt.png")


@dataclass
class IdealizedQuadraticInverseProblem(SeismicInverseProblem):
    hessian_config: dict = None  # Config Hessian for toy model

    def __post_init__(self):
        super().__post_init__()
        self.get_hess()

    def get_hess(self) -> None:
        logger.debug("Building Hessian in idealized quadratic model...")
        lr_rank: int = self.hessian_config["lr_rank"]
        lr_weight: float = self.hessian_config["lr_weight"]
        pdo_weight: float = self.hessian_config.get("pdo_weight", 1.0)
        depth_factor: str = self.hessian_config["depth_factor"]

        XX0: np.ndarray = self.XX / self.XX.max()
        YY0: np.ndarray = self.YY / self.YY.max()

        if depth_factor == "d2":
            D = (YY0**2 + 0.1) ** (-1)
        elif depth_factor == "m2":
            D = (self.mt.reshape(self.n) / self.cmin) ** (-2) * (YY0 * 2 + 1) ** (-2)
        else:
            raise ValueError(f"Unknown {depth_factor = }")

        D /= np.max(D)

        # Build Low-rank part
        evals = (1.0 + np.arange(lr_rank)) ** (-0.5) * lr_weight
        evecs = np.stack([np.sin(k * np.pi * XX0) * D for k in range(1, lr_rank + 1)])
        evecs = evecs.reshape(lr_rank, self.N).T
        evecs /= np.linalg.norm(evecs, axis=0)
        E = spla.aslinearoperator(sparse.diags(evals))
        V = spla.aslinearoperator(evecs)
        H_lr = V @ E @ V.H

        # Build POD rows (order=0.5; trim high frequencies)
        low_pass = lambda r, a, b: (r <= a) + (r > a) * (r < b) * (b - r) / (b - a)
        rows = (
            np.stack(
                [
                    0.5 * np.ones_like(self.AAf) + 0.1,
                    0.5 * np.cos(2 * self.AAf),
                    -0.5 * np.sin(2 * self.AAf),
                ]
            )
            * self.RRf**0.5
            * low_pass(self.RRf, 0.5 * self.kmax[0], 0.7 * self.kmax[0])
        )

        # Build PDO columns (windowed; decreasing-on-depth)
        cols = (
            self.window
            * D
            * np.stack(
                [
                    np.ones_like(XX0),
                    np.cos(2 * np.pi * XX0),
                    np.sin(2 * np.pi * XX0),
                ]
            )
        ) * pdo_weight

        # Hessian=Hlr+Hpdo
        H_pdo = RealPDOLowRankSymbol(cols, rows)
        H_true = H_lr + H_pdo * H_pdo.H

        # coefficients of the misfit
        b = H_true * (self.mt - self.m0)
        c = 0.5 * np.dot(b, self.mt - self.m0)

        self.H_true = H_true
        self.b = b
        self.c = c
        self.evals = evals
        self.evecs = evecs
        self.rows = rows
        self.cols = cols

    # Original misfit in terms of x (x0=0)
    def orig_misfit_cost(self, x: np.ndarray) -> float:
        return 0.5 * np.dot(self.H_true * x, x) - np.dot(self.b, x) + self.c

    def orig_misfit_grad(self, x: np.ndarray) -> np.ndarray:
        return self.H_true * x - self.b

    def orig_misfit_hess(self, x: np.ndarray) -> spla.LinearOperator:
        return self.H_true

    def show(self, n_evals=300) -> None:
        super().show()

        out_path = self.path / "model"
        out_path.mkdir(parents=True, exist_ok=True)

        plt.figure(figsize=self.x_size)
        self.plot(self.b, title=r"$b=Hx^*$", colorbar=True)
        plt.tight_layout()
        plt.savefig(out_path / "b.png")

        logger.debug("Computing eigenvalues of the Hessian...")
        evals_H, evecs_H = spla.eigsh(self.H_true, k=n_evals, return_eigenvectors=True)
        evals_H, evecs_H = evals_H[::-1], evecs_H[:, ::-1]
        evals_R = np.linalg.norm(self.sqrtR @ evecs_H, axis=0) ** 2
        fig = plt.figure(figsize=(6, 4))
        plt.semilogy(evals_H, label="$H$")
        plt.semilogy(self.evals, label=r"$H_{lr}$")
        plt.semilogy(evals_R, label="$R$")
        plt.title("Eigenvalues of the operator")
        plt.legend()
        plt.savefig(out_path / "evals.png")

        k = len(self.evals)
        fig, axes = plt.subplots(k, 2, figsize=(6 * 2, 3 * k))
        for i in range(k):
            plt.sca(axes[i, 0])
            plt.imshow(self.evecs[:, i].reshape(self.n).T)
            plt.colorbar()
            plt.title(f"No.{i+1} eigenvector of " + r"$H_{lr}$")
            plt.sca(axes[i, 1])
            plt.imshow(evecs_H[:, i].reshape(self.n).T)
            plt.colorbar()
            plt.title(f"No.{i+1} eigenvector of " + r"$H$")
        plt.tight_layout()
        plt.savefig(out_path / "evecs.png")

        logger.debug("Computing MAP point using direct linear solver...")
        HR = self.total_hess(self.m0)
        g0 = self.total_grad(self.m0)
        dm_solve = spla.cg(HR, -g0)[0]
        dm_solve = self.W * dm_solve
        plt.figure(figsize=self.x_size)
        self.plot(
            dm_solve,
            title=r"Solution $x = (H+R)^{-1} b$",
            colorbar=True,
            cbar_label="Velocity (m/s)",
        )
        plt.tight_layout()
        plt.savefig(out_path / "dm_solve.png")

        k = len(self.cols)
        width = 14
        width_ratios = (self.x_ratio, self.x_ratio, self.f_ratio)
        fig, axes = plt.subplots(
            k,
            3,
            figsize=(width, width / sum(width_ratios) * k),
            width_ratios=width_ratios,
        )
        for i in range(k):
            plt.sca(axes[i, 0])
            self.plot(self.evecs[:, i], title=f"$v_{i+1}(x)$", colorbar=True)
            plt.sca(axes[i, 1])
            self.plot(self.cols[i], title=f"$a_{i+1}(x)$", colorbar=True)
            plt.sca(axes[i, 2])
            self.plotf(self.rows[i], title=f"$b_{i+1}" + r"(\xi)$", colorbar=True)
        plt.tight_layout()
        plt.savefig(out_path / "lr_pdo.png")


@dataclass
class SesimicInverseProblemWithJuliaWaveSimulation(SeismicInverseProblem):
    client: WaveModeling = None

    def __post_init__(self):
        assert self.client is not None, "Require a client to compute f/g/Hv"
        self.compute_f = self.client.compute_f
        self.compute_g = self.client.compute_g
        self.compute_Hv = self.client.compute_H
        super().__post_init__()

    def get_window(self):
        super().get_window()
        # Zero out boundaries where our seismic gradient is inaccurate.
        self.window[0, :] = 0.0
        self.window[-1, :] = 0.0
        self.window[:, 0] = 0.0
        self.window[:, -1] = 0.0
        self.W = spla.aslinearoperator(sparse.diags(self.window.ravel()))


@dataclass
class FixWaterSesimicInverseProblemWithJuliaWaveSimulation(
    SesimicInverseProblemWithJuliaWaveSimulation
):
    nw: int = None

    def __post_init__(self):
        super().__post_init__()
        self.n_ext = np.array([self.nx, self.ny + self.nw])
        self.N_ext = np.prod(self.n_ext)
        self.L_ext = self.n_ext * self.d
        self.Z = spla.LinearOperator(  # pad zeros
            dtype=float,
            shape=(self.N_ext, self.N),
            matvec=lambda x: np.concatenate(
                [np.zeros((self.nx, self.nw)), x.reshape(self.n)], axis=1
            ).reshape(-1),
            rmatvec=lambda x_ext: x_ext.reshape(self.n_ext)[:, self.nw :].reshape(-1),
        )
        self.mt_ext = self.Z * (self.mt - self.cmin) + self.cmin
        self.m0_ext = self.Z * (self.m0 - self.cmin) + self.cmin

    def get_window(self):
        logger.debug("Generating windowing matrix...")
        kwargs = self.window_config.copy()
        method = kwargs.pop("method", "exp")
        self.window_ext = make_window(method, [self.nx, self.ny + self.nw], **kwargs)
        # Zero out boundaries where our seismic gradient is inaccurate.
        self.window_ext[0, :] = 0.0
        self.window_ext[-1, :] = 0.0
        self.window_ext[:, 0] = 0.0
        self.window_ext[:, -1] = 0.0
        self.W_ext = spla.aslinearoperator(sparse.diags(self.window_ext.ravel()))
        self.window = self.window_ext[:, self.nw :]
        self.W = spla.aslinearoperator(sparse.diags(self.window.ravel()))

    # Misfit in terms of x = m - m0
    def orig_misfit_cost_ext(self, x_ext: np.ndarray) -> float:
        return self.compute_f(self.m0_ext + x_ext) / self.noise_variance

    def orig_misfit_grad_ext(self, x_ext: np.ndarray) -> np.ndarray:
        return self.compute_g(self.m0_ext + x_ext) / self.noise_variance

    def orig_misfit_hess_ext(self, x_ext: np.ndarray) -> spla.LinearOperator:
        return spla.LinearOperator(
            shape=(self.N_ext, self.N_ext),
            dtype=float,
            matvec=lambda v_ext: self.compute_Hv(self.m0_ext + x_ext, v_ext)
            / self.noise_variance,
            rmatvec=lambda v_ext: self.compute_Hv(self.m0_ext + x_ext, v_ext)
            / self.noise_variance,
        )

    # Misfit in terms of x = m - m0
    def orig_misfit_cost(self, x: np.ndarray) -> float:
        return self.orig_misfit_cost_ext(self.Z @ x)

    def orig_misfit_grad(self, x: np.ndarray) -> np.ndarray:
        return self.Z.H @ self.orig_misfit_grad_ext(self.Z @ x)

    def orig_misfit_hess(self, x: np.ndarray) -> spla.LinearOperator:
        return self.Z.H * self.orig_misfit_hess_ext(self.Z * x) * self.Z
